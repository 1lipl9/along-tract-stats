
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>TrackVis/MATLAB Integration Demo</title><meta name="generator" content="MATLAB 7.9"><meta name="date" content="2011-01-20"><meta name="m-file" content="trk_demo"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>TrackVis/MATLAB Integration Demo</h1><!--introduction--><p>This demo takes you through the basic process of working with TrackVis track group .trk files in MATLAB. The main rationale for these tools is to be able to examine a scalar metric (e.g. FA) parameterized <i>along</i> a track, instead of the typical method of collpasing across the whole track.</p><p><tt>Author: John Colby (<a href="mailto:johncolby@ucla.edu">johncolby@ucla.edu</a>)</tt></p><p><tt>UCLA Developmental Cognitive Neuroimaging Group (Sowell Lab)</tt></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Import tracks</a></li><li><a href="#5">Whole-track statistics</a></li><li><a href="#7">Fit curves</a></li><li><a href="#12">Extract scalars</a></li><li><a href="#14">Plot results</a></li><li><a href="#15">Export tracks</a></li><li><a href="#20">Help</a></li></ul></div><h2>Import tracks<a name="1"></a></h2><p>Set paths to .trk file and scalar MRI volume (e.g. FA map).</p><pre class="codeinput">subDir  = fullfile(exDir, <span class="string">'subject1'</span>);
trkPath = fullfile(subDir, <span class="string">'CST_L.trk'</span>);
volPath = fullfile(subDir, <span class="string">'dti_fa.nii.gz'</span>);
</pre><p>Read in the scalar MRI volume with FSL tools. (See <tt>$FSLDIR/etc/matlab</tt>)</p><pre class="codeinput">volume = read_avw(volPath);
</pre><p>Read in the .trk file. You will get a <tt>header</tt> structure with fields from the .trk header, and a <tt>tracks</tt> structure array with an entry for each streamline in the track group.</p><pre class="codeinput">[header tracks] = trk_read(trkPath)
</pre><pre class="codeoutput">
header = 

                    id_string: 'TRACK '
                          dim: [192 192 55]
                   voxel_size: [1x3 double]
                       origin: [0 0 0]
                    n_scalars: 0
                  scalar_name: [10x20 char]
                 n_properties: 0
                property_name: [10x20 char]
                     reserved: [508x1 char]
                  voxel_order: 'LPS '
                         pad2: 'LAS '
    image_orientation_patient: [1 0 0 0 -1 0]
                         pad1: '  '
                     invert_x: 0
                     invert_y: 1
                     invert_z: 0
                      swap_xy: 0
                      swap_yz: 0
                      swap_zx: 0
                      n_count: 734
                      version: 2
                     hdr_size: 1000


tracks = 

1x734 struct array with fields:
    nPoints
    matrix

</pre><p>Each structure in the <tt>tracks</tt> array contains fields for the number of points in that particular streamline, and the raw matrix of those points in mm coordinates [nPoints x 3]. Coordinate system begins with RPI = 0,0,0.</p><pre class="codeinput">tracks(1)
tracks(1).matrix
</pre><pre class="codeoutput">
ans = 

    nPoints: 73
     matrix: [73x3 double]


ans =

   1.0e+02 *

   1.206250000000000   1.056250000000000   0.012500000000000
   1.207720794677734   1.059611968994141   0.026684432029724
   1.209682159423828   1.062586669921875   0.040909690856934
   1.213030853271484   1.065638732910156   0.058191952705383
   1.216317749023438   1.069971466064453   0.075074014663696
   1.218180618286133   1.075720977783203   0.088091688156128
   1.219920196533203   1.083112182617187   0.100385837554932
   1.225116729736328   1.099119567871094   0.121337203979492
   1.230795669555664   1.111412048339844   0.135634117126465
   1.236737670898437   1.123016815185547   0.150359802246094
   1.240612945556641   1.130783004760742   0.162544422149658
   1.244113311767578   1.137491912841797   0.175483188629150
   1.251192550659180   1.147262268066406   0.200166530609131
   1.260355453491211   1.154616470336914   0.225005455017090
   1.264101104736328   1.157441635131836   0.237574386596680
   1.267523040771484   1.160492095947266   0.250180339813232
   1.275066757202148   1.168136520385742   0.274111442565918
   1.279900283813477   1.171730651855469   0.287185688018799
   1.285231323242187   1.174262542724609   0.300296039581299
   1.290689697265625   1.175638504028320   0.312818317413330
   1.296115264892578   1.176560668945313   0.325406990051270
   1.306058959960938   1.178518676757812   0.350160598754883
   1.311772918701172   1.179335479736328   0.362949218750000
   1.318336639404297   1.180222396850586   0.375288124084473
   1.334649810791016   1.183249359130859   0.400182762145996
   1.342152557373047   1.184990158081055   0.412690277099609
   1.349198303222656   1.186486129760742   0.425477905273437
   1.362553253173828   1.188378143310547   0.450144348144531
   1.369225311279297   1.189425048828125   0.462571525573730
   1.374779968261719   1.189970321655273   0.475423622131348
   1.381103668212891   1.188869018554688   0.500231018066406
   1.387519989013672   1.188163299560547   0.524383773803711
   1.389322662353516   1.187186660766602   0.537330245971680
   1.390965881347656   1.186013336181641   0.550312652587891
   1.397006988525391   1.184476623535156   0.575168952941895
   1.402807617187500   1.182536163330078   0.600023460388184
   1.405141601562500   1.180226669311524   0.612736167907715
   1.406536712646484   1.177096710205078   0.625431900024414
   1.406477355957031   1.171478881835937   0.650425643920898
   1.407289886474609   1.171085968017578   0.675410003662109
   1.408264007568359   1.169998931884766   0.692015609741211
   1.408815002441406   1.167976455688477   0.708547439575195
   1.408255004882812   1.166088714599609   0.725102157592773
   1.406918334960938   1.165078353881836   0.737862625122070
   1.405901184082031   1.163328170776367   0.750468673706055
   1.406930084228516   1.156511077880859   0.775137939453125
   1.407280120849609   1.154406356811523   0.787756958007813
   1.407309265136719   1.152679290771484   0.800471343994141
   1.406544342041016   1.146499252319336   0.825326232910156
   1.403460235595703   1.138356170654297   0.850091857910156
   1.402972869873047   1.135429916381836   0.862562637329102
   1.402603454589844   1.133604888916016   0.875259017944336
   1.399994201660156   1.131861572265625   0.900062179565430
   1.398681030273438   1.130137176513672   0.912682876586914
   1.397202453613281   1.128021926879883   0.925242996215820
   1.393214721679688   1.123603134155273   0.950156707763672
   1.391793060302734   1.119912109375000   0.962992401123047
   1.390741882324219   1.114950561523437   0.975479125976562
   1.387410278320313   1.103987731933594   0.998367004394531
   1.383302917480469   1.099596557617188   1.011651916503906
   1.378654174804687   1.096871948242188   1.025312957763672
   1.375107116699219   1.095348358154297   1.037837524414063
   1.371809539794922   1.093936462402344   1.050417022705078
   1.364431457519531   1.090171508789062   1.075326843261719
   1.356357116699219   1.086820068359375   1.100070648193359
   1.351526947021484   1.083932495117188   1.112691268920899
   1.347863311767578   1.081076660156250   1.125576477050781
   1.347882385253906   1.078825988769531   1.150475006103516
   1.353712158203125   1.078758544921875   1.175428161621094
   1.361919250488281   1.077961578369141   1.200350036621094
   1.370574798583984   1.077355041503906   1.225124435424805
   1.372958984375000   1.076668090820313   1.237655105590820
   1.374422302246094   1.075755767822266   1.250406951904297

</pre><h2>Whole-track statistics<a name="5"></a></h2><p>Determine traditional statistics collapsed across the whole track.</p><pre class="codeinput">[meanInt stdInt nVox] = trk_stats(header, tracks, volume, <span class="string">'nearest'</span>)
</pre><pre class="codeoutput">
meanInt =

   0.586314621723275


stdInt =

   0.137048754045340


nVox =

        1777

</pre><p>Determine the distribution of streamline lengths.</p><pre class="codeinput">lengths = trk_length(tracks);
mean(lengths)
std(lengths)
</pre><pre class="codeoutput">
ans =

     1.217951225436152e+02


ans =

  13.173444399362362

</pre><h2>Fit curves<a name="7"></a></h2><p>Use cubic spline interpolation to make all tracks have the same number of vertices. The output is in matrix mode.</p><pre class="codeinput">tracks_interp = trk_interp(tracks, 100);
</pre><p>Reformat the tracks back into a structure form.</p><pre class="codeinput">tracks_interp_str = trk_restruc(tracks_interp);
</pre><p>Plot the track group. The last input argument indicates the slice planes for volume overlays. Red markers indicate starting points. Note the random ordering of tracks, with some "starting" in the cortex and some in the brainstem.</p><pre class="codeinput">figure, trk_plot(header, tracks_interp_str, volume, [95 78 4])
view([30 30])
</pre><img vspace="5" hspace="5" src="trk_demo_01.png" alt=""> <p>Reorder the tracks so that they all "start" in the same spot. The last input argument here is a coordinate near the desired starting area. If left blank, the origin will be determined interactively.</p><pre class="codeinput">tracks_interp     = trk_flip(header, tracks_interp, [97 110 4]);
tracks_interp_str = trk_restruc(tracks_interp);
</pre><p>Plot the results again to see the difference.</p><pre class="codeinput">figure, trk_plot(header, tracks_interp_str, volume, [95 78 4])
view([30 30])
</pre><img vspace="5" hspace="5" src="trk_demo_02.png" alt=""> <h2>Extract scalars<a name="12"></a></h2><p>For each point along the streamlines in <tt>tracks_interp_str</tt>, extract the corresponding voxel intensity from <tt>volume</tt>.</p><pre class="codeinput">[header_sc tracks_sc] = trk_add_sc(header, tracks_interp_str, volume, <span class="string">'FA'</span>);
</pre><p>Obtain the mean scalar at different points along the track</p><pre class="codeinput">[scalar_mean scalar_sd] = trk_mean_sc(header_sc, tracks_sc);
</pre><h2>Plot results<a name="14"></a></h2><p>Plot the mean scalar value (+/- SD) along the track.</p><pre class="codeinput">figure, hold <span class="string">on</span>
plot(scalar_mean, <span class="string">'k'</span>)
plot(scalar_mean+scalar_sd, <span class="string">'k--'</span>)
plot(scalar_mean-scalar_sd, <span class="string">'k--'</span>)

<span class="comment">% Make the plot prettier</span>
hold <span class="string">off</span>, box <span class="string">off</span>
xlim([0 100]), ylim([0 1])
title(<span class="string">'\bf{Mean FA along track}'</span>)
xlabel(<span class="string">'Distance along track (%)'</span>)
ylabel(<span class="string">'Fractional Anisotropy (FA)'</span>)
</pre><img vspace="5" hspace="5" src="trk_demo_03.png" alt=""> <h2>Export tracks<a name="15"></a></h2><p>The mean streamline geometry can also be calculated.</p><pre class="codeinput">track_mean = mean(tracks_interp, 3);
</pre><p>This can be packaged up with the mean scalar values. Multiple scalars can be added, and can even include statistical significance values. A dummy streamline should be added with the desired display ranges for the scalars, if these exceed the ranges in the data.</p><pre class="codeinput">track_mean_sc     = [track_mean scalar_mean];
<span class="comment">%                         x y z   sc1</span>
track_mean_sc(1:2,:,2) = [0 0 0   0;  <span class="comment">%min</span>
                          0 0 0.1 1]; <span class="comment">%max</span>
track_mean_sc_str = trk_restruc(track_mean_sc);
</pre><p>Don't forget to update the header because now we only have 1 streamline instead of many (plus the 1 dummy streamline).</p><pre class="codeinput">header_mean_sc         = header_sc;
header_mean_sc.n_count = 2;
</pre><p>Save the result back out to a .trk file for visualization in TrackVis.</p><pre class="codeinput">savePath = fullfile(exDir, <span class="string">'CST_L_mean.trk'</span>);
trk_write(header_mean_sc, track_mean_sc_str, savePath)
</pre><p><img vspace="5" hspace="5" src="mean_track.png" alt=""> </p><h2>Help<a name="20"></a></h2><p>To get more help for any of these functions, simply type <tt>help function_name</tt> at the command prompt.</p><pre class="codeinput">help <span class="string">trk_stats</span>
</pre><pre class="codeoutput"> TRK_STATS - Compute intensity statistics about a volume within a track group
 Use this function to extract the mean/etc. of a scalar MRI volume within a
 select track group of interest. For instance, you could calculate the mean
 FA within the left corticospinal tract.
 
  Syntax: [meanInt,stdInt,nVox] = trk_stats(header,tracks,volume,method)
 
  Inputs:
     header - Header information from .trk file [struc]
     tracks - Track data struc array [1 x nTracks]
     volume - Scalar MRI volume
     method - Method to use for extracting intensities from the MRI volume
       quick   - Extract intensities directly. This uses linear indexing to  
                 avoid a for loop and is ~ 5x faster than the higher-level
                 nearest neighbor version below.
       nearest - Nearest neighbor interpolation. Should be equivalent to direct 
                 lookup.
       cubic   - Cubic interpolation instead of direct voxel lookup.
 
  Outputs:
     meanInt - Mean image volume intensity (e.g. FA) along a track group
     stdInt  - Standard deviation of these intensities
     nVox    - Number of unique voxels traversed by the track group
 
  Example:
     [header tracks]       = trk_read(trkPath);
     volume                = read_avw(volPath);
     [meanInt stdInt nVox] = trk_stats(header, tracks, volume, 'quick')
 
  Other m-files required: trk_restruc
  Subfunctions: none
  MAT-files required: none
 
  See also: TRK_READ, READ_AVW

</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.9<br></p></div><!--
##### SOURCE BEGIN #####
%% TrackVis/MATLAB Integration Demo
% This demo takes you through the basic process of working with TrackVis track
% group .trk files in MATLAB. The main rationale for these tools is to be able
% to examine a scalar metric (e.g. FA) parameterized _along_ a track, instead
% of the typical method of collpasing across the whole track.
%
% |Author: John Colby (johncolby@ucla.edu)|
%
% |UCLA Developmental Cognitive Neuroimaging Group (Sowell Lab)|

%% Import tracks
% Set paths to .trk file and scalar MRI volume (e.g. FA map).
subDir  = fullfile(exDir, 'subject1');
trkPath = fullfile(subDir, 'CST_L.trk');
volPath = fullfile(subDir, 'dti_fa.nii.gz');

%%
% Read in the scalar MRI volume with FSL tools. (See |$FSLDIR/etc/matlab|)
volume = read_avw(volPath);

%%
% Read in the .trk file. You will get a |header| structure with fields from the .trk
% header, and a |tracks| structure array with an entry for each streamline in
% the track group.
[header tracks] = trk_read(trkPath)

%%
% Each structure in the |tracks| array contains fields for the number of points
% in that particular streamline, and the raw matrix of those points in mm 
% coordinates [nPoints x 3]. Coordinate system begins with RPI = 0,0,0.
tracks(1)
tracks(1).matrix

%% Whole-track statistics
% Determine traditional statistics collapsed across the whole track.
[meanInt stdInt nVox] = trk_stats(header, tracks, volume, 'nearest')

%%
% Determine the distribution of streamline lengths.
lengths = trk_length(tracks);
mean(lengths)
std(lengths)

%% Fit curves
% Use cubic spline interpolation to make all tracks have the same number of
% vertices. The output is in matrix mode.
tracks_interp = trk_interp(tracks, 100);

%%
% Reformat the tracks back into a structure form.
tracks_interp_str = trk_restruc(tracks_interp);

%%
% Plot the track group. The last input argument indicates the slice planes for 
% volume overlays. Red markers indicate starting points. Note the random
% ordering of tracks, with some "starting" in the cortex and some in the brainstem.
figure, trk_plot(header, tracks_interp_str, volume, [95 78 4])
view([30 30])

%%
% Reorder the tracks so that they all "start" in the same spot. The last input
% argument here is a coordinate near the desired starting area. If left blank,
% the origin will be determined interactively.
tracks_interp     = trk_flip(header, tracks_interp, [97 110 4]);
tracks_interp_str = trk_restruc(tracks_interp);

%%
% Plot the results again to see the difference.
figure, trk_plot(header, tracks_interp_str, volume, [95 78 4])
view([30 30])

%% Extract scalars
% For each point along the streamlines in |tracks_interp_str|, extract the corresponding voxel
% intensity from |volume|.
[header_sc tracks_sc] = trk_add_sc(header, tracks_interp_str, volume, 'FA');

%%
% Obtain the mean scalar at different points along the track
[scalar_mean scalar_sd] = trk_mean_sc(header_sc, tracks_sc);

%% Plot results
% Plot the mean scalar value (+/- SD) along the track.
figure, hold on
plot(scalar_mean, 'k')
plot(scalar_mean+scalar_sd, 'kREPLACE_WITH_DASH_DASH')
plot(scalar_mean-scalar_sd, 'kREPLACE_WITH_DASH_DASH')

% Make the plot prettier
hold off, box off
xlim([0 100]), ylim([0 1])
title('\bf{Mean FA along track}')
xlabel('Distance along track (%)')
ylabel('Fractional Anisotropy (FA)')

%% Export tracks
% The mean streamline geometry can also be calculated.
track_mean = mean(tracks_interp, 3);

%%
% This can be packaged up with the mean scalar values. Multiple scalars can be
% added, and can even include statistical significance values. A dummy
% streamline should be added with the desired display ranges for the scalars, if
% these exceed the ranges in the data.
track_mean_sc     = [track_mean scalar_mean];
%                         x y z   sc1
track_mean_sc(1:2,:,2) = [0 0 0   0;  %min
                          0 0 0.1 1]; %max
track_mean_sc_str = trk_restruc(track_mean_sc);

%%
% Don't forget to update the header because now we only have 1 streamline
% instead of many (plus the 1 dummy streamline).
header_mean_sc         = header_sc;
header_mean_sc.n_count = 2;

%%
% Save the result back out to a .trk file for visualization in TrackVis.
savePath = fullfile(exDir, 'CST_L_mean.trk');
trk_write(header_mean_sc, track_mean_sc_str, savePath)
%%
% <<mean_track.png>>


%% Help
% To get more help for any of these functions, simply type |help function_name|
% at the command prompt.
help trk_stats
##### SOURCE END #####
--></body></html>